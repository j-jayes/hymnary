---
title: "Hymnâ€“Tune Index"
subtitle: "All 182 Allen organ hymns and their associated tunes from Hymnary.org"
---

```{python}
#| echo: false
#| output: asis

import json
from pathlib import Path

# Prefer filtered data if available, fall back to raw scrape
filtered_path = Path("../data/processed/hymn_tune_index_filtered.json")
raw_path = Path("../data/processed/hymn_tune_index.json")
classifications_path = Path("../data/processed/classifications.json")

if filtered_path.exists():
    data_path = filtered_path
    is_filtered = True
elif raw_path.exists():
    data_path = raw_path
    is_filtered = False
else:
    print("""
::: {.callout-warning}
## Data Not Yet Available
The scraping pipeline has not been run yet. Run `uv run python -m src.pipeline` from the project root to collect tune data from Hymnary.org.
:::
""")
    data_path = None

if data_path:
    hymn_data = json.loads(data_path.read_text())
    
    # Load classification reasoning if available
    clf_data = {}
    if classifications_path.exists():
        clf_data = json.loads(classifications_path.read_text())

    total_hymns = len(hymn_data)
    total_tunes = sum(len(h.get("tunes_found", [])) for h in hymn_data)
    unique_slugs = set()
    for h in hymn_data:
        for t in h.get("tunes_found", []):
            if t.get("tune_slug"):
                unique_slugs.add(t["tune_slug"])
    
    if is_filtered and clf_data:
        # Count excluded tunes from classifications
        excluded = 0
        for clf in clf_data.values():
            for c in clf.get("consensus", []):
                if not c.get("is_relevant", True):
                    excluded += 1
        
        # Check for Excel download
        excel_path = Path("hymn_tune_data.xlsx")
        excel_link = '\n\nðŸ“¥ **[Download full dataset as Excel](hymn_tune_data.xlsx)** â€” includes all tune results, AI classification, and metadata.' if excel_path.exists() else ''
        
        print(f"""
::: {{.callout-note}}
## LLM-Filtered Results
Tune relevance was verified using GPT-5.2 (3-run majority vote). **{total_tunes} relevant tunes** kept, **{excluded} false positives** removed.{excel_link}
:::

*Showing {total_hymns} organ hymns with {total_tunes} relevant tune associations ({len(unique_slugs)} unique tunes).*
""")
    else:
        print(f"""
::: {{.callout-info}}
## Unfiltered Results
These results have not yet been filtered by the LLM classifier. Run `uv run python -m src.filter_pipeline` to classify tunes.
:::

*Showing {total_hymns} organ hymns with {total_tunes} tune associations ({len(unique_slugs)} unique tunes).*
""")
```

```{python}
#| echo: false

import json
import pandas as pd
from pathlib import Path
from IPython.display import HTML, display

filtered_path = Path("../data/processed/hymn_tune_index_filtered.json")
raw_path = Path("../data/processed/hymn_tune_index.json")
classifications_path = Path("../data/processed/classifications.json")
matches_path = Path("../data/processed/organ_book_matches.csv")

data_path = filtered_path if filtered_path.exists() else raw_path

if data_path and data_path.exists():
    hymn_data = json.loads(data_path.read_text())

    # Build relevance lookup from classifications
    clf_data = {}
    if classifications_path.exists():
        clf_data = json.loads(classifications_path.read_text())

    relevance_lookup = {}
    for hymn_key, clf in clf_data.items():
        for entry in clf.get("consensus", []):
            relevance_lookup[(hymn_key, entry["tune_slug"])] = entry

    # Book Matches Lookup
    book_matches = set()
    if matches_path.exists():
        try:
            df_match = pd.read_csv(matches_path)
            if "in_hymn_book" in df_match.columns and "tune_slug" in df_match.columns:
                 # Get set of slugs that are matched
                book_matches = set(df_match[df_match["in_hymn_book"] == True]["tune_slug"].dropna())
        except Exception:
            pass

    # Build HTML table
    rows = []
    for hymn in hymn_data:
        title = hymn["full_title"]
        console = hymn["console_display"]
        hymn_key = hymn["hymn_key"]
        tunes = hymn.get("tunes_found", [])
        search_total = hymn.get("total_search_results", "â€”")
        
        if not tunes:
            rows.append(f"""
            <tr>
                <td><strong>{title}</strong><br>
                    <small class="text-muted">{console}</small></td>
                <td colspan="7"><em>No tunes found</em></td>
            </tr>""")
            continue
            
        for i, t in enumerate(tunes):
            detail = t.get("detail", {})
            card = t.get("search_card", {})
            tune_title = detail.get("title", card.get("title", "â€”"))
            composer = detail.get("composer", "â€”")
            meter = detail.get("meter", "â€”")
            key_sig = detail.get("key", "â€”")
            slug = t.get("tune_slug", "")
            url = f"https://hymnary.org/tune/{slug}" if slug else "#"
            n_hymnals = detail.get("num_hymnals", card.get("num_hymnals", "â€”"))

            # MIDI link
            midi_url = detail.get("midi_url", "")
            midi_cell = f'<a href="{midi_url}" title="Download MIDI">ðŸŽµ</a>' if midi_url else ""

            # Book Match Icon
            book_cell = ""
            if slug in book_matches:
                book_cell = '<span title="Match found in Mission Praise" style="font-size: 1.2em;">ðŸ“–</span>'

            # Confidence badge from classification
            clf_entry = relevance_lookup.get((hymn_key, slug), {})
            confidence = clf_entry.get("confidence", "")
            reasoning = clf_entry.get("reasoning", "")
            vote = clf_entry.get("vote_count", "")
            total_runs = clf_entry.get("total_runs", "")
            
            badge = ""
            if confidence:
                badge_class = {
                    "high": "badge-high",
                    "medium": "badge-medium",
                    "low": "badge-low",
                }.get(confidence, "badge-medium")
                vote_str = f"{vote}/{total_runs}" if vote != "" else ""
                badge = f'<span class="relevance-badge {badge_class}" title="{reasoning}">{confidence} ({vote_str})</span>'
            
            hymn_cell = (
                f'<strong>{title}</strong><br>'
                f'<small class="text-muted">{console}</small><br>'
                f'<small class="search-count">{search_total} results</small>'
            ) if i == 0 else ""
            rowspan = f' rowspan="{len(tunes)}"' if i == 0 else ""
            td_hymn = f'<td{rowspan}>{hymn_cell}</td>' if i == 0 else ""
            
            rows.append(f"""
            <tr>
                {td_hymn}
                <td><a href="{url}" target="_blank">{tune_title}</a> {badge}</td>
                <td class="text-center">{book_cell}</td>
                <td>{composer}</td>
                <td>{meter}</td>
                <td>{key_sig}</td>
                <td>{n_hymnals}</td>
                <td class="text-center">{midi_cell}</td>
            </tr>""")
    
    table_html = f"""
    <div class="table-responsive">
    <table class="table table-striped table-hover">
    <thead>
        <tr>
            <th style="min-width:200px">Hymn</th>
            <th>Tune</th>
            <th class="text-center" width="50">Book</th>
            <th>Composer</th>
            <th>Meter</th>
            <th>Key</th>
            <th>Hymnals</th>
            <th>MIDI</th>
        </tr>
    </thead>
    <tbody>
        {"".join(rows)}
    </tbody>
    </table>
    </div>
    """
    display(HTML(table_html))
```
